use std::io::Read;

use crate::compress::{RCompressData, Result};
use crate::support::BitwiseWrite;

const USHRT_MAX: u16 = u16::MAX;

impl<R: Read, W: BitwiseWrite> RCompressData<R, W> {
  pub fn write_bit_length_table_data_to_output(
    &mut self,
    bit_length_tree_size: i16,
    bit_length: i16,
    run_start_check: i16,
  ) -> Result<()> {
    pure_fn218(
      &mut self.output_store,
      &self.bit_length_huff_bit_length,
      cast!(bit_length_tree_size as usize),
      cast!(bit_length as usize),
      cast!(run_start_check as i8),
    )
  }
}

fn pure_fn218<W>(
  out: &mut W,
  bit_length_huff_bit_length: &[u8],
  bit_length_tree_size: usize,
  bit_length: usize,
  bit_lengths_start: i8,
) -> Result<()>
where
  W: BitwiseWrite,
{
  // - If `bit_lengths_start == 3`, then we are being called with the huffman encoding generated by
  //    `_216`, which stores information about the byte/run length huffman encoding. Specifically
  //    `0..3` stores information about the gaps between values in the table, and `3..19` stores
  //    information about the number of bits each value consumes.
  // - If `bit_lengths_start == -1`, then we are being called with the huffman encoding for offset
  //    lengths generated by `_202`.
  assert!(bit_lengths_start == -1 || bit_lengths_start == 3);

  let mut last_entry = bit_length_tree_size;
  while last_entry > 0 && bit_length_huff_bit_length[last_entry - 1] == 0 {
    last_entry -= 1
  }
  out.write_bits(last_entry, bit_length)?;
  let mut idx: usize = 0;
  while idx < last_entry {
    let bit_length = bit_length_huff_bit_length[idx];
    idx += 1;
    if bit_length <= 6 {
      out.write_bits(bit_length, 3)?;
    } else {
      out.write_bits(USHRT_MAX << 1, bit_length - 3)?;
    }
    // The original code has this as `run_start_check` == `idx`; however given the function only has
    //  2 calling sites, and the only values that are passed are `3` and `-1`, I've chosen to simply
    //  check for `== 3` twice.
    if bit_lengths_start == 3 && idx == 3 {
      while idx < 6 && bit_length_huff_bit_length[idx] == 0 {
        idx += 1
      }
      // Write out `0b00` if the smallest encoded value uses a 1 bit encoding; `0b01` for a 2 bit
      //  encoding etc. up to `0b11` for a 3 or higher bit encoding.
      out.write_bits(idx - 3, 2)?;
    }
  }
  Ok(())
}
#[cfg(test)]
mod tests {
  use super::*;
  use crate::support::ExpectedCallWriter;

  #[test]
  fn test_fn218_0() {
    let dat_arr181 = vec![7, 7, 6, 0, 0, 0, 6, 5, 1, 2, 4, 4, 5, 6, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (14, 5),
      (65534, 4),
      (65534, 4),
      (6, 3),
      (3, 2),
      (6, 3),
      (5, 3),
      (1, 3),
      (2, 3),
      (4, 3),
      (4, 3),
      (5, 3),
      (6, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_1() {
    let dat_arr181 = vec![5, 3, 4, 4, 4, 4, 5, 4, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (5, 3),
      (3, 3),
      (4, 3),
      (4, 3),
      (4, 3),
      (4, 3),
      (5, 3),
      (4, 3),
      (3, 3),
      (2, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_2() {
    let dat_arr181 = vec![7, 3, 4, 5, 4, 6, 7, 4, 3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (65534, 4),
      (3, 3),
      (4, 3),
      (5, 3),
      (4, 3),
      (6, 3),
      (65534, 4),
      (4, 3),
      (3, 3),
      (2, 3),
      (2, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_3() {
    let dat_arr181 = vec![6, 0, 4, 0, 0, 0, 6, 3, 1, 3, 4, 4, 5, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (13, 5),
      (6, 3),
      (0, 3),
      (4, 3),
      (3, 2),
      (6, 3),
      (3, 3),
      (1, 3),
      (3, 3),
      (4, 3),
      (4, 3),
      (5, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_4() {
    let dat_arr181 = vec![5, 5, 3, 4, 4, 3, 3, 4, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (5, 3),
      (5, 3),
      (3, 3),
      (4, 3),
      (4, 3),
      (3, 3),
      (3, 3),
      (4, 3),
      (3, 3),
      (3, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_5() {
    let dat_arr181 = vec![4, 7, 5, 0, 0, 0, 8, 8, 1, 3, 5, 5, 4, 3, 6, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (15, 5),
      (4, 3),
      (65534, 4),
      (5, 3),
      (3, 2),
      (65534, 5),
      (65534, 5),
      (1, 3),
      (3, 3),
      (5, 3),
      (5, 3),
      (4, 3),
      (3, 3),
      (6, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_6() {
    let dat_arr181 = vec![5, 2, 3, 4, 5, 5, 5, 4, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (5, 3),
      (2, 3),
      (3, 3),
      (4, 3),
      (5, 3),
      (5, 3),
      (5, 3),
      (4, 3),
      (3, 3),
      (3, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_7() {
    let dat_arr181 = vec![0, 3, 2, 3, 0, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (8, 5),
      (0, 3),
      (3, 3),
      (2, 3),
      (0, 2),
      (3, 3),
      (0, 3),
      (3, 3),
      (3, 3),
      (2, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_8() {
    let dat_arr181 = vec![0, 6, 5, 0, 0, 0, 6, 6, 1, 2, 5, 6, 3, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (13, 5),
      (0, 3),
      (6, 3),
      (5, 3),
      (3, 2),
      (6, 3),
      (6, 3),
      (1, 3),
      (2, 3),
      (5, 3),
      (6, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_9() {
    let dat_arr181 = vec![1, 0, 0, 0, 0, 3, 3, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (10, 5),
      (1, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (3, 3),
      (3, 3),
      (3, 3),
      (0, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_10() {
    let dat_arr181 = vec![0, 3, 2, 0, 3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (7, 5),
      (0, 3),
      (3, 3),
      (2, 3),
      (1, 2),
      (3, 3),
      (2, 3),
      (2, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_11() {
    let dat_arr181 = vec![1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (1, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (2, 3),
      (0, 3),
      (0, 3),
      (2, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_12() {
    let dat_arr181 = vec![0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls =
      ExpectedCallWriter::from_vec(vec![(4, 5), (0, 3), (0, 3), (1, 3), (0, 2), (1, 3)]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_13() {
    let dat_arr181 = vec![5, 3, 3, 5, 4, 3, 3, 3, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (5, 3),
      (3, 3),
      (3, 3),
      (5, 3),
      (4, 3),
      (3, 3),
      (3, 3),
      (3, 3),
      (4, 3),
      (3, 3),
      (4, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_14() {
    let dat_arr181 = vec![2, 3, 6, 0, 0, 6, 0, 5, 4, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (2, 3),
      (3, 3),
      (6, 3),
      (2, 2),
      (6, 3),
      (0, 3),
      (5, 3),
      (4, 3),
      (2, 3),
      (2, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_15() {
    let dat_arr181 = vec![0, 5, 5, 0, 0, 0, 6, 3, 1, 3, 3, 5, 6, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (13, 5),
      (0, 3),
      (5, 3),
      (5, 3),
      (3, 2),
      (6, 3),
      (3, 3),
      (1, 3),
      (3, 3),
      (3, 3),
      (5, 3),
      (6, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_16() {
    let dat_arr181 = vec![4, 5, 5, 0, 0, 0, 7, 7, 2, 2, 3, 5, 6, 3, 4, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (15, 5),
      (4, 3),
      (5, 3),
      (5, 3),
      (3, 2),
      (65534, 4),
      (65534, 4),
      (2, 3),
      (2, 3),
      (3, 3),
      (5, 3),
      (6, 3),
      (3, 3),
      (4, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_17() {
    let dat_arr181 = vec![3, 4, 2, 4, 0, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (8, 5),
      (3, 3),
      (4, 3),
      (2, 3),
      (0, 2),
      (4, 3),
      (0, 3),
      (3, 3),
      (2, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_18() {
    let dat_arr181 = vec![1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (9, 5),
      (1, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (0, 3),
      (1, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_19() {
    let dat_arr181 = vec![2, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls =
      ExpectedCallWriter::from_vec(vec![(4, 5), (2, 3), (0, 3), (2, 3), (0, 2), (1, 3)]);
    pure_fn218(&mut expected_calls, &dat_arr181, 19, 5, 3).unwrap();
    expected_calls.assert_drained();
  }

  #[test]
  fn test_fn218_20() {
    let dat_arr181 = vec![6, 3, 3, 4, 6, 5, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut expected_calls = ExpectedCallWriter::from_vec(vec![
      (11, 5),
      (6, 3),
      (3, 3),
      (3, 3),
      (4, 3),
      (6, 3),
      (5, 3),
      (3, 3),
      (3, 3),
      (3, 3),
      (3, 3),
      (3, 3),
    ]);
    pure_fn218(&mut expected_calls, &dat_arr181, 15, 5, -1).unwrap();
    expected_calls.assert_drained();
  }
}
